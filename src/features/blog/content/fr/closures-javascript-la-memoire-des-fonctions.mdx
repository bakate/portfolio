---
title: "Closures JavaScript : Quand tes Fonctions ont une M√©moire d'√âl√©phant üêò"
pubDate: 2025-05-26
description: 'En JavaScript, tes fonctions se souviennent de leur pass√© ! D√©couvre les closures, ce super-pouvoir discret qui rend ton code plus malin.'
tags:
  [
    'JavaScript',
    'Closures',
    'Scope',
    'D√©veloppement Web',
    'Fonctions',
    'Node.js',
  ]
lang: 'fr'
isDraft: false
heroImage:
  url: '../../../../assets/blog/closure.jpg'
  alt: 'Closure JavaScript'
relatedPosts:
  [
    'fr/fonctions-javascript-specialisation-es6',
    'fr/javascript-typeof-null-evolution',
  ]

articleTocItems:
  - text: 'Le Secret R√©v√©l√©'
    href: '#le-secret-revele'
  - text: 'Comment √ßa Marche ?'
    href: '#comment-ca-marche'
    subItems:
      - {
          text: 'Le Quartier des Variables',
          href: '#le-quartier-des-variables',
        }
      - { text: 'Les Cl√©s du Myst√®re', href: '#les-cles-du-mystere' }
  - text: 'Les Super-Pouvoirs au Quotidien'
    href: '#les-super-pouvoirs-au-quotidien'
    subItems:
      - { text: 'Cr√©er des Coffres-Forts', href: '#creer-des-coffres-forts' }
      - { text: 'Les Usines √† Fonctions', href: '#les-usines-a-fonctions' }
      - { text: 'Ma√Ætriser le Temps', href: '#maitriser-le-temps' }
  - text: 'Le Pi√®ge Classique'
    href: '#le-piege-classique'
  - text: 'Ton Nouveau Super-Pouvoir'
    href: '#ton-nouveau-super-pouvoir'
  - text: 'Exemples pratiques'
    href: '#exemples-pratiques'
---

import InfoAlert from '../../components/InfoAlert.astro';
import TableOfContents from '../../components/TableOfContents.astro';
import StackBlitzEmbed from '../../components/StackBlitzEmbed.astro';

## J'ai une r√©v√©lation √† te faire üëÄ

En JavaScript, **chaque fonction peut garder en m√©moire son pass√©** : elle se souvient de l‚Äôenvironnement o√π elle est n√©e. Ce super-pouvoir s‚Äôappelle une **closure**.

> üìå Une closure, c‚Äôest une **fonction combin√©e avec son environnement lexical**. En gros, elle garde une m√©moire vivante de l√† o√π elle est n√©e.

Et le plus fou ? **Tu les utilises d√©j√† tous les jours sans forc√©ment le savoir.**

On d√©cortique √ßa ? C‚Äôest parti !

---

<TableOfContents
  tocItems={frontmatter.articleTocItems}
  lang={frontmatter.lang}
/>

<div id="le-secret-revele" />

## Le Secret R√©v√©l√© üòâ : Toutes tes Fonctions sont des Closures !

Oui, tu as bien lu ! **Chaque fonction que tu √©cris en JavaScript est techniquement une closure**. M√™me la plus simple des fonctions "ferme sur" son environnement.

Mais ce qui rend les closures vraiment puissantes, c‚Äôest qu‚Äôelles **se souviennent de leur environnement m√™me apr√®s ex√©cution de la fonction parente**. Comme si elles emportaient avec elles un Polaro√Ød de leur maison d‚Äôenfance.

### Une m√©taphore pour mieux visualiser

Pense √† une **maman** qui √©l√®ve son **enfant** avec amour. Elle lui transmet des valeurs, des conseils, des secrets de famille. Un jour, l'enfant quitte la maison...

**Mais voil√† le truc super** : m√™me loin du domicile familial, l'enfant se souvient encore de tout ce que sa maman lui a appris. Les le√ßons de vie, les recettes secr√®tes, les petites habitudes familiales...

En JavaScript, c'est pareil ! Quand une fonction "enfant" na√Æt √† l'int√©rieur d'une fonction "maman", elle h√©rite de cette capacit√© extraordinaire √† se souvenir de son foyer d'origine.

<div id="comment-ca-marche" />

## Comment √ßa Marche Concr√®tement ?

<div id="le-quartier-des-variables" />

### Le Quartier des Variables (Scope Lexical)

Imagine JavaScript comme une ville avec des quartiers. Chaque fonction vit dans son propre quartier, mais elle peut voir ce qui se passe dans les quartiers voisins !

```javascript
// Le centre-ville (scope global)
const ville = 'JavaScript City';

function quartier(nomQuartier) {
  // Le quartier r√©sidentiel
  const service = 'Biblioth√®que municipale';

  function maison(numero) {
    // La maison individuelle
    const couleurPorte = 'Bleue';

    // La maison peut voir TOUT :
    console.log(
      `On habite au ${numero}, quartier ${nomQuartier}, ville ${ville}`
    );
    console.log(`Notre porte est ${couleurPorte}`);
    console.log(`On a acc√®s √† la ${service}`);
  }

  maison(42);
}

quartier('Centre');
```

La fonction `maison` voit non seulement ses propres affaires (`couleurPorte`), mais aussi celles de son quartier parent (`service`, `nomQuartier`) et m√™me de la ville toute enti√®re (`ville`) !

<div id="les-cles-du-mystere" />

### Les Cl√©s du Myst√®re : Variables Libres vs Li√©es

Dans notre maison JavaScript, il y a deux types de "possessions" :

**üîê Variables Li√©es** (ce qui t'appartient vraiment)

- Tes param√®tres de fonction
- Les variables que tu d√©clares dans ta fonction. Elles prennent le dessus si jamais elles sont nomm√©es de la m√™me mani√®re que des variables libres.

**üóùÔ∏è Variables Libres** (l'h√©ritage familial)

- Si tu utilises une variable mais qu'elle n'est pas d√©clar√©e dans ta fonction, elle est recherch√©e dans l'environnement parent. Si elle n'y est pas, elle est recherch√©e chez les grands-parents, et ainsi de suite.
- **C'est √ßa qui rend les closures puissants !**

```javascript
function maman(cadeau) {
  const secretFamille = 'La recette des cookies de grand-m√®re';
  let humeurDuJour = 'Joyeuse';

  function enfant(decouverte) {
    const jouetPrefere = 'Mon dino en peluche'; // Variable LI√âE
    console.log(`J'ai d√©couvert : "${decouverte}"`);

    // Variables LIBRES (h√©rit√©es de maman) :
    console.log(`Maman m'a dit : "${secretFamille}"`);
    console.log(`Maman est ${humeurDuJour} aujourd'hui`);
    console.log(`Maman m'a offert : "${cadeau}"`);

    // Variable LI√âE (√† moi) :
    console.log(`Mon jouet pr√©f√©r√© : "${jouetPrefere}"`);
  }

  humeurDuJour = 'Fatigu√©e mais aimante'; // On peut changer avant le retour !
  return enfant;
}

const monEnfant = maman('Un livre sur les plan√®tes');
monEnfant('La Terre tourne autour du soleil !');
```

<InfoAlert title="√Ä Retenir">
  Les closures ne copient pas les valeurs, elles gardent un **lien vivant** (ou
  **r√©f√©rence**) vers les variables originales. Si la variable change dans le
  parent, l'enfant verra la nouvelle valeur !
</InfoAlert>

<div id="les-super-pouvoirs-au-quotidien" />

## Les Super-Pouvoirs des Closures au Quotidien

Maintenant qu'on a compris le principe, voyons pourquoi c'est si utile dans la vraie vie !

<div id="creer-des-coffres-forts" />

### üîí Cr√©er des Coffres-Forts : Variables Inaccessibles de l‚ÄôExt√©rieur

Avant les classes modernes, les closures √©taient la m√©thode reine pour simuler des variables priv√©es.
Ici, la variable `count` est **prot√©g√©e** : seul l‚Äôobjet retourn√© peut l‚Äôutiliser. Personne d‚Äôautre ne peut y acc√©der ni la modifier.

```javascript
function createCounter() {
  let count = 0; // Variable priv√©e, impossible d'y acc√©der de l'ext√©rieur !

  return {
    increment() {
      count += 1;
      console.log(`Counter: ${count}`);
    },
    decrement() {
      count -= 1;
      console.log(`Counter: ${count}`);
    },
    getValue() {
      return count;
    },
    // Pas de m√©thode pour acc√©der directement √† 'count' !
  };
}

const compteur1 = createCounter();
compteur1.increment(); // Compteur : 1
compteur1.increment(); // Compteur : 2

const compteur2 = createCounter();
compteur2.increment(); // Compteur : 1 (son propre compteur !)

// Impossible de pirater le compteur :
// console.log(compteur1.valeur); // undefined - la variable est prot√©g√©e !
```

<div id="les-usines-a-fonctions" />

### üè≠ Fabriquer des Fonctions sur Mesure

Les closures excellent pour fabriquer des fonctions pr√©configur√©es.

```javascript
function createSalutation(typeDeBonjour) {
  return function (nom) {
    console.log(`${typeDeBonjour}, ${nom} ! Comment √ßa va ?`);
  };
}

// On cr√©e nos fonctions personnalis√©es
const direBonjour = createSalutation('Salut');
const direHello = createSalutation('Hello');
const direCoucou = createSalutation('Coucou');

// Chacune se souvient de SON type de salutation
direBonjour('Marie'); // Salut, Marie ! Comment √ßa va ?
direHello('John'); // Hello, John ! Comment √ßa va ?
direCoucou('Pierre'); // Coucou, Pierre ! Comment √ßa va ?
```

Un autre exemple avec ce calculateur

```javascript
function createCalculateur(operation) {
  return function (a, b) {
    switch (operation) {
      case 'addition':
        return `${a} + ${b} = ${a + b}`;
      case 'multiplication':
        return `${a} √ó ${b} = ${a * b}`;
      case 'puissance':
        return `${a}^${b} = ${Math.pow(a, b)}`;
      default:
        return 'Op√©ration inconnue !';
    }
  };
}

const additionner = createCalculateur('addition');
const multiplier = createCalculateur('multiplication');
const puissance = createCalculateur('puissance');

console.log(additionner(5, 3)); // 5 + 3 = 8
console.log(multiplier(4, 7)); // 4 √ó 7 = 28
console.log(puissance(2, 3)); // 2^3 = 8
```

<div id="maitriser-le-temps" />

### ‚è∞ Ma√Ætriser le Temps avec des Closures Asynchrones

Les closures sont cruciales en programmation asynchrone, notamment avec les callbacks.

```javascript
function scheduleTasks() {
  const tasks = [
    { name: 'Appeler grand-m√®re', delay: 3000 },
    { name: 'Faire tes devoirs', delay: 1000 },
    { name: 'Ranger ta chambre', delay: 2000 },
  ];

  console.log("üìã J'assigne toutes les t√¢ches...");

  tasks.forEach((task) => {
    // Chaque setTimeout capture SA propre version de 'tache'
    setTimeout(() => {
      console.log(`‚è∞ C'est l'heure de : ${task.name} !`);
    }, task.delay);
  });
}

scheduleTasks();
// üìã J'assigne toutes les t√¢ches...
// (apr√®s 1s) ‚è∞ C'est l'heure de : Faire tes devoirs !
// (apr√®s 2s) ‚è∞ C'est l'heure de : Ranger ta chambre !
// (apr√®s 3s) ‚è∞ C'est l'heure de : Appeler grand-m√®re !
```

<div id="le-piege-classique" />

## ‚ö†Ô∏è Le Pi√®ge Classique des Boucles

Attention, un pi√®ge fr√©quent guette avec les closures dans les boucles, surtout si l'on utilise `var`.

```javascript
// ‚ùå LE PROBL√àME (avec var)
console.log("‚ùå Avec 'var' - Le pi√®ge :");
for (var i = 0; i < 3; i++) {
  setTimeout(function () {
    console.log(`Valeur de i : ${i}`); // Que va-t-il se passer ?
  }, 100);
}
// R√©sultat inattendu : "3, 3, 3" au lieu de "0, 1, 2" !

// ‚úÖ LA SOLUTION (avec let)
console.log("\n‚úÖ Avec 'let' - La solution :");
for (let i = 0; i < 3; i++) {
  setTimeout(function () {
    console.log(`Valeur de i : ${i}`); // Maintenant √ßa marche !
  }, 200);
}
// R√©sultat attendu : "0, 1, 2" üéâ
```

**Pourquoi ce probl√®me ?**
Avec `var`, toutes les fonctions `setTimeout` acc√®dent √† la **m√™me instance** de la variable `i`, car `var` ne cr√©e pas de scope bloc. R√©sultat : elles voient toutes la derni√®re valeur.
Avec `let`, c'est diff√©rent : `let` cr√©e une **nouvelle liaison (binding) de `i` pour chaque it√©ration de la boucle**. Chaque closure capture donc sa propre version de `i`, celle qui correspond √† son tour de boucle.

**L'ancienne solution (avant `let`) :**

```javascript
// üîß Ancienne m√©thode avec IIFE (Immediately Invoked Function Expression)
for (var i = 0; i < 3; i++) {
  (function (indexActuel) {
    setTimeout(function () {
      console.log(`Index captur√© : ${indexActuel}`);
    }, 300);
  })(i); // On passe 'i' √† la fonction qui l'ex√©cute imm√©diatement
}
```

<InfoAlert title="Conseil Pratique">
  **Utilise toujours `let` ou `const` dans tes boucles** au lieu de `var`. C'est
  plus simple et √ßa √©vite ce pi√®ge classique !
</InfoAlert>

<div id="ton-nouveau-super-pouvoir" />

### Dans les Frameworks Modernes

Les closures ne sont pas juste un d√©tail technique - elles sont au c≈ìur de

**React avec les Hooks :**

```javascript
function MonComposant() {
  const [count, setCount] = useState(0);
  const nomComposant = 'Super Compteur';

  // Cette fonction est une closure !
  function gererClic() {
    console.log(`${nomComposant} cliqu√© ! Nouvelle valeur : ${count + 1}`);
    setCount(count + 1);
  }

  return <button onClick={gererClic}>Compter : {count}</button>;
}
```

**Vue.js avec la Composition API :**

```javascript
import { ref } from 'vue';

export default {
  setup() {
    const message = ref('Salut Vue !');

    // Closure qui capture 'message'
    const changerMessage = () => {
      message.value = 'Message chang√© gr√¢ce √† une closure !';
    };

    return { message, changerMessage };
  },
};
```

**Angular avec Signals :**

Avec l'arriv√©e des Signals, Angular offre une mani√®re r√©active et concise de g√©rer l'√©tat, o√π les closures jouent un r√¥le cl√© notamment dans les `effect`.

```typescript
// Angular avec Signals et Closures
import { Component, signal, effect } from '@angular/core';

@Component({
  selector: 'signal-closure-demo',
  template: `
    <p>Compteur (Signal) : {{ count() }}</p>
    <button (click)="increment()">Incr√©menter</button>
    <p>{{ messageFromEffect() }}</p>
  `,
})
export class SignalClosureDemoComponent {
  count = signal(0);
  messageFromEffect = signal('Initialisation...');
  // Cette variable sera captur√©e par la closure de l'effect.
  private componentCreationTime: string;

  constructor() {
    this.componentCreationTime = new Date().toLocaleTimeString(); // Simplifi√©

    // L'effect est une closure.
    // Il "capture" `this.count` et `this.componentCreationTime` de l'instance du composant.
    effect(() => {
      const currentCount = this.count(); // Acc√®s au signal
      // Utilise la valeur de componentCreationTime captur√©e lors de la cr√©ation de la closure.
      const logMessage = `[Composant initialis√© √† ${this.componentCreationTime}] Le compteur est : ${currentCount}.`;
      console.log(logMessage);
      this.messageFromEffect.set(logMessage); // Met √† jour un autre signal depuis l'effect
    });
  }

  increment() {
    // La fonction pass√©e √† update est aussi une closure.
    // Elle capture `currentValue` (son param√®tre) mais pourrait aussi capturer
    // des variables du scope de `increment` si n√©cessaire.
    this.count.update((currentValue) => currentValue + 1);
  }
}
```

Dans cet exemple Angular avec Signals :

- L'appel √† `effect()` enregistre une fonction callback. Cette fonction est une **closure** : elle "se souvient" et a acc√®s aux signaux (`this.count`) et aux propri√©t√©s (`this.componentCreationTime`) de l'instance de `SignalClosureDemoComponent` o√π elle a √©t√© d√©finie.
- Chaque fois que `this.count` est modifi√© via la m√©thode `increment()`, l'effect s'ex√©cute √† nouveau, utilisant les valeurs captur√©es (notamment `this.componentCreationTime` qui reste constant depuis l'initialisation du composant) et la nouvelle valeur de `this.count()`.
- La fonction fl√©ch√©e `currentValue => currentValue + 1` pass√©e √† `this.count.update()` est √©galement une closure.

**Astro :**

Dans Astro, les closures se manifestent souvent c√¥t√© serveur lors de la g√©n√©ration des pages, ou c√¥t√© client dans les scripts et les composants de framework (React, Vue, Svelte, etc.) qu'Astro peut int√©grer.

```typescript
// Dans un fichier .astro (partie script front-end)
// Ce code s'ex√©cute c√¥t√© client.
<script>
const boutons = document.querySelectorAll('.bouton-astro');
const messages = [
  'Premier message secret Astro !',
  'Deuxi√®me secret Astro !',
  'Troisi√®me secret Astro !',
];

boutons.forEach((bouton, index) => {
  // La valeur de 'index' et 'messages[index]' est captur√©e pour chaque event listener.
  // C'est une closure !
  const messagePourCeBouton =
    messages[index % messages.length] || 'Message par d√©faut';

  bouton.addEventListener('click', () => {
    console.log(`Bouton Astro #${index + 1} dit : ${messagePourCeBouton}`);
    alert(`Message : ${messagePourCeBouton}`);
  });
});
</script>

<div>
  <button class="bouton-astro">Bouton Astro 1</button>
  <button class="bouton-astro">Bouton Astro 2</button>
  <button class="bouton-astro">Bouton Astro 3</button>
</div>
```

Ici, chaque `addEventListener` cr√©e une closure qui "se souvient" de la valeur sp√©cifique de `messagePourCeBouton` et `index` pour ce bouton particulier, m√™me apr√®s que la boucle `forEach` ait termin√© son ex√©cution.

### Techniques Avanc√©es

**Currying (aper√ßu) :**

```javascript
// Transform une fonction √† plusieurs param√®tres...
function multiply(a, b) {
  return a * b;
}

// ...en une cha√Æne de fonctions √† un param√®tre !
function multiplyCurry(a) {
  return function (b) {
    return a * b; // 'a' est captur√© par la closure
  };
}

const multiplyBy5 = multiplyCurry(5);
console.log(multiplyBy5(3)); // 15
console.log(multiplyBy5(7)); // 35
```

### ‚ö†Ô∏è Un Petit Avertissement

Les closures peuvent parfois causer des **fuites m√©moire** si tu n'y fais pas attention. Si une closure capture de gros objets qui ne sont plus utilis√©s, ils ne pourront pas √™tre supprim√©s de la m√©moire.

**Exemple √† √©viter :**

```javascript
function problematique() {
  const enormeObjet = new Array(1000000).fill('data'); // Tr√®s gros !

  return function () {
    console.log("Je garde l'√©norme objet en m√©moire inutilement...");
    // Cette closure capture 'enormeObjet' m√™me si on ne l'utilise pas !
  };
}
```

**Solution :**

```javascript
function mieux() {
  const enormeObjet = new Array(1000000).fill('data');
  const donneeNecessaire = enormeObjet.length; // On extrait ce qu'il faut

  return function () {
    console.log(`J'ai juste besoin de la taille : ${donneeNecessaire}`);
    // Maintenant 'enormeObjet' peut √™tre nettoy√© de la m√©moire !
  };
}
```

<div id="exemples-pratiques" />

### Exemples Bonus √† Explorer üí°

Pour "sentir" les closures, c'est de les voir en action. Je t'ai pr√©par√© plusieurs exemples dans un environnement interactif. Tu pourras jouer avec le code et observer leur comportement directement !

<StackBlitzEmbed
  projectId="vitejs-closure-examples"
  cardTitle="Playground intr√©actif sur les closures"
/>
